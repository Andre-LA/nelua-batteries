require 'string'
require 'math'

--------------------------------------------------------------------------------
-- MbedTLS imports

## linklib 'mbedcrypto'

-- Error
## cinclude '<mbedtls/error.h>'
global MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL: cint <cimport,nodecl,const>
local function mbedtls_low_level_strerr(error_code: cint): cstring <cimport,nodecl> end

-- Big Num
## cinclude '<mbedtls/bignum.h>'
local mbedtls_mpi: type <cimport,nodecl> = @record{
  s: cint,
  n: csize,
  p: *uint64
}
local function mbedtls_mpi_init(X: *mbedtls_mpi): void <cimport,nodecl> end
local function mbedtls_mpi_free(X: *mbedtls_mpi): void <cimport,nodecl> end
local function mbedtls_mpi_grow(X: *mbedtls_mpi, nblimbs: csize): cint <cimport,nodecl> end
local function mbedtls_mpi_copy(X: *mbedtls_mpi, Y: *mbedtls_mpi): cint <cimport,nodecl> end
local function mbedtls_mpi_lset(X: *mbedtls_mpi, z: clong): cint <cimport,nodecl> end
local function mbedtls_mpi_get_bit(X: *mbedtls_mpi, pos: csize): cint <cimport,nodecl> end
local function mbedtls_mpi_set_bit(X: *mbedtls_mpi, pos: csize, val: cuchar): cint <cimport,nodecl> end
local function mbedtls_mpi_lsb(X: *mbedtls_mpi): csize <cimport,nodecl> end
local function mbedtls_mpi_bitlen(X: *mbedtls_mpi): csize <cimport,nodecl> end
local function mbedtls_mpi_size(X: *mbedtls_mpi): csize <cimport,nodecl> end
local function mbedtls_mpi_read_string(X: *mbedtls_mpi, radix: cint, s: cstring): cint <cimport,nodecl> end
local function mbedtls_mpi_write_string(X: *mbedtls_mpi, radix: cint, buf: cstring, buflen: csize, olen: *csize): cint <cimport,nodecl> end
local function mbedtls_mpi_read_binary(X: *mbedtls_mpi, buf: *cuchar, buflen: csize): cint <cimport,nodecl> end
local function mbedtls_mpi_read_binary_le(X: *mbedtls_mpi, buf: *cuchar, buflen: csize): cint <cimport,nodecl> end
local function mbedtls_mpi_write_binary(X: *mbedtls_mpi, buf: *cuchar, buflen: csize): cint <cimport,nodecl> end
local function mbedtls_mpi_write_binary_le(X: *mbedtls_mpi, buf: *cuchar, buflen: csize): cint <cimport,nodecl> end
local function mbedtls_mpi_shift_l(X: *mbedtls_mpi, count: csize): cint <cimport,nodecl> end
local function mbedtls_mpi_shift_r(X: *mbedtls_mpi, count: csize): cint <cimport,nodecl> end
local function mbedtls_mpi_cmp_mpi(X: *mbedtls_mpi, Y: *mbedtls_mpi): cint <cimport,nodecl> end
local function mbedtls_mpi_add_abs(X: *mbedtls_mpi, A: *mbedtls_mpi, B: *mbedtls_mpi): cint <cimport,nodecl> end
local function mbedtls_mpi_add_mpi(X: *mbedtls_mpi, A: *mbedtls_mpi, B: *mbedtls_mpi): cint <cimport,nodecl> end
local function mbedtls_mpi_sub_mpi(X: *mbedtls_mpi, A: *mbedtls_mpi, B: *mbedtls_mpi): cint <cimport,nodecl> end
local function mbedtls_mpi_mul_mpi(X: *mbedtls_mpi, A: *mbedtls_mpi, B: *mbedtls_mpi): cint <cimport,nodecl> end
local function mbedtls_mpi_div_mpi(Q: *mbedtls_mpi, R: *mbedtls_mpi, A: *mbedtls_mpi, B: *mbedtls_mpi): cint <cimport,nodecl> end
local function mbedtls_mpi_mod_mpi(R: *mbedtls_mpi, A: *mbedtls_mpi, B: *mbedtls_mpi): cint <cimport,nodecl> end
local function mbedtls_mpi_exp_mod(X: *mbedtls_mpi, A: *mbedtls_mpi, E: *mbedtls_mpi, N: *mbedtls_mpi, prec_RR: *mbedtls_mpi): cint <cimport,nodecl> end
local function mbedtls_mpi_fill_random(X: *mbedtls_mpi, size: csize, f_rng: function(pointer, *cuchar, csize): cint, p_rng: pointer): cint <cimport,nodecl> end
local function mbedtls_mpi_random(X: *mbedtls_mpi, min: clong, N: *mbedtls_mpi, f_rng: function(pointer, *cuchar, csize): cint, p_rng: pointer): cint <cimport,nodecl> end
local function mbedtls_mpi_gcd(G: *mbedtls_mpi, A: *mbedtls_mpi, B: *mbedtls_mpi): cint <cimport,nodecl> end
local function mbedtls_mpi_inv_mod(X: *mbedtls_mpi, A: *mbedtls_mpi, N: *mbedtls_mpi): cint <cimport,nodecl> end

-- RNG
## cinclude '<mbedtls/entropy.h>'
## cinclude '<mbedtls/ctr_drbg.h>'
local mbedtls_aes_context: type <cimport,nodecl> = @record{
  nr: cint,
  rk: *uint32,
  buf: [68]uint32
}
local mbedtls_threading_mutex_t: type <cimport,nodecl,cincomplete> = @record{
  is_valid: cchar
}
local mbedtls_ctr_drbg_context: type <cimport,nodecl> = @record{
  counter: [16]cuchar,
  reseed_counter: cint,
  prediction_resistance: cint,
  entropy_len: csize,
  reseed_interval: cint,
  aes_ctx: mbedtls_aes_context,
  f_entropy: function(pointer, *cuchar, csize): cint,
  p_entropy: pointer,
  mutex: mbedtls_threading_mutex_t
}
local function mbedtls_ctr_drbg_init(ctx: *mbedtls_ctr_drbg_context): void <cimport,nodecl> end
local function mbedtls_ctr_drbg_seed(ctx: *mbedtls_ctr_drbg_context, f_entropy: function(pointer, *cuchar, csize): cint, p_entropy: pointer, custom: *cuchar, len: csize): cint <cimport,nodecl> end
local function mbedtls_ctr_drbg_random(p_rng: pointer, output: *cuchar, output_len: csize): cint <cimport,nodecl> end

local mbedtls_sha512_context: type <cimport,nodecl> = @record{
  total: [2]uint64,
  state: [8]uint64,
  buffer: [128]cuchar,
  is384: cint
}
local mbedtls_entropy_f_source_ptr: type <cimport,nodecl> = @function(pointer, *cuchar, csize, *csize): cint
local mbedtls_entropy_source_state: type <cimport,nodecl> = @record{
  f_source: mbedtls_entropy_f_source_ptr,
  p_source: pointer,
  size: csize,
  threshold: csize,
  strong: cint
}
local mbedtls_entropy_context: type <cimport,nodecl> = @record{
  accumulator_started: cint,
  accumulator: mbedtls_sha512_context,
  source_count: cint,
  source: [20]mbedtls_entropy_source_state,
  mutex: mbedtls_threading_mutex_t
}
local function mbedtls_entropy_init(ctx: *mbedtls_entropy_context): void <cimport,nodecl> end
local function mbedtls_entropy_free(ctx: *mbedtls_entropy_context): void <cimport,nodecl> end
local function mbedtls_entropy_func(data: pointer, output: *cuchar, len: csize): cint <cimport,nodecl> end

--------------------------------------------------------------------------------
-- Helpers

-- Utility to check and raise big integer errors.
local function mbedtls_check(res: cint): void
  if unlikely(res ~= 0) then
    error(mbedtls_low_level_strerr(res))
  end
end

-- Cleanup big integer resources when the garbage collector is enabled.
function mbedtls_mpi:__gc()
  mbedtls_mpi_free(self)
end

-- Auxiliary macro to convert strings, integers to big integers.
##[[
local function ensure_bigints(...)
  for i=1,select('#',...) do
    local sym = select(i, ...)
    ]]
    local #|sym.name|#: BigInt <close> = BigInt.from(#[sym]#)
    ##[[
  end
end
]]

-- Concept that accept any value that is convertible to a big integer.
local BigInt_convertible: type = #[concept(function(x)
  return x.type.is_integral or x.type.is_bigint or x.type.is_string
end)]#

--------------------------------------------------------------------------------
-- The Big Integer

-- The big integer record.
local BigInt: type = @record{
  mpi: *mbedtls_mpi
}
## BigInt.value.is_bigint = true

-- Destroys the big integer, freeing its resources.
function BigInt:destroy(): void
  if not self.mpi then return end
  mbedtls_mpi_free(self.mpi)
  delete(self.mpi)
  self.mpi = nilptr
end

-- Allow cleaning up resources with to-be-closed variables.
function BigInt:__close(): void
  self:destroy()
end

-- Returns the total storage size in bytes.
function BigInt.__len(self: BigInt): usize
  return mbedtls_mpi_size(self.mpi)
end

-- Return the total storage size in bits.
function BigInt.bitlen(x: BigInt_convertible): usize
  ## ensure_bigints(x)
  return mbedtls_mpi_bitlen(x.mpi)
end

-- Returns a new big integer with zero value stored.
function BigInt.zero(): BigInt
  local self: BigInt
  self.mpi = new(@mbedtls_mpi)
  mbedtls_mpi_init(self.mpi)
  return self
end

-- Returns a clone of a big integer.
function BigInt.copy(x: BigInt): BigInt
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_copy(res.mpi, x.mpi))
  return res
end

--------------------------------------------------------------------------------
-- Functions for unserializing big integers

function BigInt.frombytes(data: string, little_endian: facultative(boolean)): BigInt
  ## if little_endian.type.is_niltype then
  local little_endian: boolean = false
  ## end
  local res: BigInt = BigInt.zero()
  if little_endian then
    mbedtls_check(mbedtls_mpi_read_binary_le(res.mpi, data.data, data.size))
  else
    mbedtls_check(mbedtls_mpi_read_binary(res.mpi, data.data, data.size))
  end
  return res
end

function BigInt.fromstring(s: string, base: facultative(int32)): BigInt
  local self: BigInt = BigInt.zero()
  ## if base.type.is_niltype then
  local base: int32
  if #s >= 2 and s:subview(1,2) == '0x' then -- hexadecimal
    base = 16
    s = s:subview(3,-1)
  elseif #s >= 2 and s:subview(1,2) == '0b' then -- binary
    base = 2
    s = s:subview(3,-1)
  else -- should be decimal
    base = 10
  end
  ## end
  mbedtls_check(mbedtls_mpi_read_string(self.mpi, base, s))
  return self
end

function BigInt.frominteger(x: integer): BigInt
  -- for some reason 'mbedtls_mpi_lset' does not work with negative values on TCC compiler
  if x >= 0 and x <= 0x7fffffff then
    local self: BigInt = BigInt.zero()
    if x ~= 0 then
      mbedtls_check(mbedtls_mpi_lset(self.mpi, x))
    end
    return self
  else
    local s: string <close> = tostring(x)
    return BigInt.fromstring(s)
  end
end

function BigInt.from(v: BigInt_convertible): BigInt
  ## if v.type.is_integral then
    return BigInt.frominteger(v)
  ## elseif v.type.is_string then
    return BigInt.fromstring(v)
  ## elseif v.type.is_bigint then
    return v:copy()
  ## end
end

--------------------------------------------------------------------------------
-- Functions for serializing big integers

function BigInt.tobytes(x: BigInt_convertible, little_endian: facultative(boolean), size: facultative(usize)): string
  ## ensure_bigints(x)
  ## if little_endian.type.is_niltype then
  local little_endian: boolean = false
  ## end
  ## if size.type.is_niltype then
  local size: usize = #x
  ## end
  assert(size >= #x, 'BigInt.tobytes: desired buffer size is not not enough')
  local data: string = string.create(size)
  if little_endian then
    mbedtls_check(mbedtls_mpi_write_binary_le(x.mpi, data.data, data.size))
  else
    mbedtls_check(mbedtls_mpi_write_binary(x.mpi, data.data, data.size))
  end
  return data
end

-- Returns the big integer as a string in the desired base.
function BigInt.tostring(x: BigInt_convertible, base: facultative(int32)): string
  ## ensure_bigints(x)
  ## if base.type.is_niltype then
  local base: int32 = 10
  ## end
  local sb: stringbuilder <close>
  local len: csize
  mbedtls_mpi_write_string(x.mpi, base, nilptr, 0, &len)
  if len > 0 then
    local buf: span(byte) = sb:prepare(len)
    mbedtls_check(mbedtls_mpi_write_string(x.mpi, base, buf.data, buf.size, &len))
    sb:commit(len-1)
  end
  return sb:view():lower()
end

-- Returns the big integer as an integer.
function BigInt.tointeger(x: BigInt_convertible): integer
  ## ensure_bigints(x)
  -- TODO: this can be optimized by using tobytes
  local s: string <close> = x:tostring()
  return tointeger(s)
end

-- Returns the big integer as a string in decimal base.
function BigInt.__tostring(x: BigInt_convertible): string
  ## ensure_bigints(x)
  return x:tostring(10)
end

--------------------------------------------------------------------------------
-- Comparison metamethods

function BigInt.__lt(a: BigInt_convertible, b: BigInt_convertible): boolean
  ## ensure_bigints(a, b)
  return mbedtls_mpi_cmp_mpi(a.mpi, b.mpi) < 0
end

function BigInt.__le(a: BigInt_convertible, b: BigInt_convertible): boolean
  ## ensure_bigints(a, b)
  return mbedtls_mpi_cmp_mpi(a.mpi, b.mpi) <= 0
end

function BigInt.__eq(a: BigInt_convertible, b: BigInt_convertible): boolean
  ## ensure_bigints(a, b)
  return mbedtls_mpi_cmp_mpi(a.mpi, b.mpi) == 0
end

--------------------------------------------------------------------------------
-- Arithmetic metamethods

function BigInt.__add(a: BigInt_convertible, b: BigInt_convertible): BigInt
  ## ensure_bigints(a, b)
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_add_mpi(res.mpi, a.mpi, b.mpi))
  return res
end

function BigInt.__sub(a: BigInt_convertible, b: BigInt_convertible): BigInt
  ## ensure_bigints(a, b)
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_sub_mpi(res.mpi, a.mpi, b.mpi))
  return res
end

function BigInt.__mul(a: BigInt_convertible, b: BigInt_convertible): BigInt
  ## ensure_bigints(a, b)
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_mul_mpi(res.mpi, a.mpi, b.mpi))
  return res
end

function BigInt.__idiv(a: BigInt_convertible, b: BigInt_convertible): BigInt
  ## ensure_bigints(a, b)
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_div_mpi(res.mpi, nilptr, a.mpi, b.mpi))
  return res
end

function BigInt.__mod(a: BigInt_convertible, b: BigInt_convertible): BigInt
  ## ensure_bigints(a, b)
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_mod_mpi(res.mpi, a.mpi, b.mpi))
  return res
end

function BigInt.__pow(base: BigInt_convertible, exp: integer): BigInt
  local b <close> = BigInt.from(base)
  local res: BigInt = BigInt.frominteger(1)
  while exp ~= 0 do
    if exp & 1 == 1 then
      mbedtls_check(mbedtls_mpi_mul_mpi(res.mpi, res.mpi, b.mpi))
    end
    exp = exp >> 1
    mbedtls_check(mbedtls_mpi_mul_mpi(b.mpi, b.mpi, b.mpi))
  end
  return res
end

function BigInt.__unm(x: BigInt_convertible): BigInt
  ## ensure_bigints(x)
  return 0 - x
end

--------------------------------------------------------------------------------
-- Bitwise metamethods

-- Performs a logical left shift.
function BigInt.__shl(a: BigInt_convertible, count: integer): BigInt
  ## ensure_bigints(a)
  local res: BigInt = a:copy()
  mbedtls_check(mbedtls_mpi_shift_l(res.mpi, count))
  return res
end

--[[
Performs a right shift on the absolute value.
Caution when using this as it does not follow two-complement arithmetic rules,
because this does not perform a real logical shift nor an arithmetic shift.
]]
function BigInt.__shr(a: BigInt_convertible, count: integer): BigInt
  ## ensure_bigints(a)
  local res: BigInt = a:copy()
  mbedtls_check(mbedtls_mpi_shift_r(res.mpi, count))
  return res
end

function BigInt.__bor(a: BigInt_convertible, b: BigInt_convertible): BigInt
  ## ensure_bigints(a, b)
  local res: BigInt = BigInt.zero()
  for i: usize=0,<math.max(a:bitlen(), b:bitlen()) do
    local bit: cint = mbedtls_mpi_get_bit(a.mpi, i) | mbedtls_mpi_get_bit(b.mpi, i)
    mbedtls_check(mbedtls_mpi_set_bit(res.mpi, i, bit))
  end
  return res
end

function BigInt.__band(a: BigInt_convertible, b: BigInt_convertible): BigInt
  ## ensure_bigints(a, b)
  local res: BigInt = BigInt.zero()
  for i: usize=0,<math.max(a:bitlen(), b:bitlen()) do
    local bit: cint = mbedtls_mpi_get_bit(a.mpi, i) & mbedtls_mpi_get_bit(b.mpi, i)
    mbedtls_check(mbedtls_mpi_set_bit(res.mpi, i, bit))
  end
  return res
end

function BigInt.__bxor(a: BigInt_convertible, b: BigInt_convertible): BigInt
  ## ensure_bigints(a, b)
  local res: BigInt = BigInt.zero()
  for i: usize=0,<math.max(a:bitlen(), b:bitlen()) do
    local bit: cint = mbedtls_mpi_get_bit(a.mpi, i) ~ mbedtls_mpi_get_bit(b.mpi, i)
    mbedtls_check(mbedtls_mpi_set_bit(res.mpi, i, bit))
  end
  return res
end

--[[
Performs a bitwise not.
Caution when using this as it does not follow two-complement arithmetic rules,
it will only flip existing bits of the absolute value.
]]
function BigInt.__bnot(a: BigInt_convertible): BigInt
  ## ensure_bigints(a)
  local res: BigInt = a:copy()
  for i: usize=0,<res:bitlen() do
    local bit: cint = mbedtls_mpi_get_bit(res.mpi, i) == 0 and 1 or 0
    mbedtls_check(mbedtls_mpi_set_bit(res.mpi, i, bit))
  end
  return res
end

--------------------------------------------------------------------------------
-- Extra methods

function BigInt.abs(a: BigInt_convertible): BigInt
  ## ensure_bigints(a)
  local res: BigInt = BigInt.zero()
  local b: BigInt <close> = BigInt.zero()
  mbedtls_check(mbedtls_mpi_add_abs(res.mpi, a.mpi, b.mpi))
  return res
end

function BigInt.divmod(dividend: BigInt_convertible, divisor: BigInt_convertible): (BigInt, BigInt)
  ## ensure_bigints(dividend, divisor)
  local quotient: BigInt = BigInt.zero()
  local remainder: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_div_mpi(quotient.mpi, remainder.mpi, dividend.mpi, divisor.mpi))
  return quotient, remainder
end

-- Computes the modular exponentiation.
function BigInt.expmod(base: BigInt_convertible, exponent: BigInt_convertible, n: BigInt_convertible): BigInt
  ## ensure_bigints(base, exponent, n)
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_exp_mod(res.mpi, base.mpi, exponent.mpi, n.mpi, nilptr))
  return res
end

-- Computes the modular inverse.
function BigInt.invmod(a: BigInt_convertible, n: BigInt_convertible): BigInt
  ## ensure_bigints(a, n)
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_inv_mod(res.mpi, a.mpi, n.mpi))
  return res
end

-- Computes the greatest common divisor.
function BigInt.gcd(a: BigInt_convertible, b: BigInt_convertible): BigInt
  ## ensure_bigints(a, b)
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_gcd(res.mpi, a.mpi, b.mpi))
  return res
end

-- Computes the least common multiple.
function BigInt.lcm(a: BigInt_convertible, b: BigInt_convertible): BigInt
  ## ensure_bigints(a, b)
  local ab: BigInt <close> = a * b
  local nume: BigInt <close> = ab:abs()
  local deno: BigInt <close> = a:gcd(b)
  return nume // deno
end

--------------------------------------------------------------------------------
-- Extra metamethods

-- Allows to implicitly convert integer and strings to big integers.
function BigInt.__convert(v: BigInt_convertible): BigInt
  return BigInt.from(v)
end

--------------------------------------------------------------------------------
-- RNG methods

-- initialize RNG
local rng: mbedtls_ctr_drbg_context
local entropy: mbedtls_entropy_context
local rng_initialized: boolean = false

local function ensure_rng_initialized()
  if rng_initialized then return end
  mbedtls_entropy_init(&entropy)
  mbedtls_ctr_drbg_init(&rng)
  mbedtls_check(mbedtls_ctr_drbg_seed(&rng, mbedtls_entropy_func, &entropy, nilptr, 0))
  rng_initialized = true
end

-- Returns a random big int in the range [min,max).
function BigInt.randomrange(min: integer, max: BigInt_convertible): BigInt
  ## ensure_bigints(max)
  ensure_rng_initialized()
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_random(res.mpi, min, max.mpi, mbedtls_ctr_drbg_random, &rng))
  return res
end

-- Returns a random big int with `size` bytes.
function BigInt.randombytes(size: usize): BigInt
  ensure_rng_initialized()
  local res: BigInt = BigInt.zero()
  mbedtls_check(mbedtls_mpi_fill_random(res.mpi, size, mbedtls_ctr_drbg_random, &rng))
  return res
end

return BigInt
