--[[
Algorithm module contains various algorithms to be used in containers,
such as sort and stable sort.
]]

require 'allocators.general'

global algorithm: type = @record{}

-- Concept used to pass contiguous containers by reference.
local sortable_reference_concept: type = #[concept(function(x)
  local container_type = x.type:implicit_deref_type()
  if not container_type.is_contiguous then
    return false, string.format("type '%s' cannot be a reference to a contiguous container", x.type)
  end
  if container_type.is_sequence then
    return false, 'sort does not support yet sequence containers'
  end
  return types.PointerType(container_type)
end)]#

-- Auxiliary macro to compare values being sorted.
## local function sort_lt(comp, a, b)
  ## if comp.type.is_niltype then
    in #[a]# < #[b]#
  ## elseif comp.type.is_function then
    in comp(#[a]#, #[b]#)
  ## else
    ## static_error('`comp` is not comparison function')
  ## end
## end

--[[
Sorts contiguous container `a` elements into ascending order.

If `comp` is given, then it must be a function that receives two list elements
and returns true when the first element must come before the second in the final order,
so that, after the sort, `i <= j` implies `not comp(a[j],a[i])`.
If `comp` is not given, then the standard operator `<` is used instead.

The sort algorithm is stable, that is,
different elements considered equal by the given order will preserve their relative positions.

The sort algorithm may not be in-place, that is,
it may allocates an auxiliary buffer temporarily to perform the sort operation,
use `heapsort` if you wish to avoid that.
]]
function algorithm.sort(a: sortable_reference_concept, comp: auto): void
  -- Tim Sort
  local T: type = #[a.type.subtype.subtype]#
  local n: isize = #a
  if n <= 1 then return end
  local run: isize = 0
  do -- calculate run
    local m: isize = n
    while m >= 64 do
      run = run | (m & 1)
      m = m >> 1
    end
    run = run + m
  end
  -- Insertion Sort
  local high: isize = n-1
  for left: isize=0,high,run do
    local right: isize = left+run-1
    if high < right then right = high end
    for i: isize = left + 1,right do
      local x: T = a[i]
      local j: isize = i - 1
      while j >= left and #[sort_lt]#(comp, x, a[j]) do
        a[j+1] = a[j]
        j = j - 1
      end
      a[j+1] = x
    end
  end
  -- Merge Sort
  if run > high then return end
  local aux: span(T) = general_allocator:spanalloc(@T, n)
  local width: isize = run
  while width <= high do
    local left_start: isize = 0
    while left_start < high do
      local left_end: isize = left_start + width - 1
      local right: isize = left_end + 1
      if right > high then break end
      local right_end: isize = left_end + width
      if right_end > high then right_end = high end
      do -- merge
        local left: isize = left_start
        local i: isize = left_start
        while left <= left_end and right <= right_end do
          local value_left: T, value_right: T = a[left], a[right]
          if #[sort_lt]#(comp, value_right, value_left) then
            aux[i] = value_right
            right = right + 1
          else
            aux[i] = value_left
            left = left + 1
          end
          i = i + 1
        end
        while left <= left_end do
          aux[i] = a[left]
          i = i + 1
          left = left + 1
        end
        while right <= right_end do
          aux[i] = a[right]
          i = i + 1
          right = right + 1
        end
        for j: isize=left_start,right_end do
          a[j] = aux[j]
        end
      end
      left_start = left_start + width + width
    end
    width = width + width
  end
  general_allocator:spandealloc(aux)
end

--[[
Like `sort` but the operation is done in-place, that is, no temporary extra memory is allocated.
Sorts all contiguous container `a` elements into ascending order (in-place).

The sort algorithm is not stable, that is,
different elements considered equal by the given order may have their
relative positions changed by the sort.
]]
function algorithm.heapsort(a: sortable_reference_concept, comp: auto): void
  -- Heap sort (as in http://en.wikibooks.org/wiki/Algorithm_implementation/Sorting/Heapsort)
  local n: isize = #a
  if n <= 1 then return end
  local i: isize = n // 2
  local parent: isize, child: isize
  local t
  while true do
    if i > 0 then
      i = i - 1
      t = a[i]
    else
      n = n -1
      if n <= 0 then return end
      t = a[n]
      a[n] = a[0]
    end
    parent = i
    child = i * 2 + 1
    while child < n do
      if child + 1 < n and #[sort_lt]#(comp, a[child], a[child + 1]) then
        child = child + 1
      end
      if #[sort_lt]#(comp, t, a[child]) then
        a[parent] = a[child]
        parent = child
        child = parent * 2 + 1
      else
        break
      end
    end
    a[parent] = t
  end
end

return algorithm
