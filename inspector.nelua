--[[
The inspector module.

This module it's a function that receives anything and
returns the whole content of the passed value as a string.
]]

require 'string'
local stringbuilder = require 'stringbuilder'

-- meta-utils
##[=[
local function is_simple_primitive(type)
  return type.is_boolean or type.is_scalar or type.is_stringy
end

local short_suffixes = {
  integer = '_i',
  uinteger = '_u',
  number = '_n',
  byte = '_b',
  isize = '_is',
  int8 = '_i8',
  int16 = '_i16',
  int32 = '_i32',
  int64 = '_i64',
  int128 = '_i128',
  usize = '_us',
  uint8 = '_u8',
  uint16 = '_u16',
  uint32 = '_u32',
  uint64 = '_u64',
  uint128 = '_u128',
  float32 = '_f32',
  float64 = '_f64',
  float128 = '_f128',
}

local function inspect_procedure_value(value)
  static_assert(value.type.is_procedure, 'value is not a procedure!')
  return tostring(value.type)
end
]=]

-- concepts
local a_simple_primitive = #[concept(function(attr) return is_simple_primitive(attr.type) end)]#
local a_array = #[concept(function(attr) return attr.type.is_array end)]#
local a_enum_value = #[concept(function(attr) return attr.type.is_enum end)]#
local a_record_value = #[concept(function(attr) return attr.type.is_record end)]#
local a_non_aggregate = #[concept(function(attr) return not attr.type.is_aggregate end)]#
local a_pointer = #[concept(function(attr) return attr.type.is_pointer end)]#
local a_stringy = #[concept(function(attr) return attr.type.is_cstring or attr.type.is_string end)]#
local a_function = #[concept(function(attr) return attr.type.is_function end)]#
local a_union = #[concept(function(attr) return attr.type.is_union end)]#

-- specialized inspector functions
local function inspect_union_value(value: a_union)
  return tostring(#['(@' .. tostring(value.type) .. ")() --[[ @" .. value.type:typedesc() .. " ]]"]#)
end

local function inspect_function_value(value: a_function, ctx: string <comptime>): string
  local function fn_hex_ptr(callback: auto)
    local cb_str <close> = tostring(callback)
    return cb_str:gsub('function: ', '', 1)
  end

  ## if ctx.value == 'field' then
    ## local type_fn = ' --[[ ' .. inspect_procedure_value(value) .. ' ]]'

    if value == nilptr then
      return tostring (#['nilptr' .. type_fn]#)
    else
      local sb: stringbuilder <close>
      local vl <close> = fn_hex_ptr(value)
      sb:write(vl, #[type_fn]#)
      return tostring(sb)
    end

  ## elseif ctx.value == 'array element' then
    local sb: stringbuilder <close>
    local vl <close> = fn_hex_ptr(value)
    sb:write(vl)
    return tostring(sb)

  ## else
    return tostring (#[inspect_procedure_value(value)]#)
  ## end
end

local function inspect_pointer_value(value: a_pointer): string
  local sb: stringbuilder <close>
  if value then
    sb:write(value, #[' --[[ @' .. tostring(value.type) .. ' ]]']#)
  else
    sb:write(#['nilptr --[[ @' .. tostring(value.type) .. ' ]]']#)
  end
  return tostring(sb)
end

local function inspect_stringy_value(value: a_stringy): string
  local sb: stringbuilder <close>
  sb:write('"', value, '"')
  ## if value.type.is_cstring then
    sb:write(' --[[ @cstring ]]')
  ## end
  return tostring(sb)
end

local function inspect_simple_value(value: a_simple_primitive, use_suffix: boolean <comptime>): string
  ## local type_suffix = short_suffixes[value.type.name]

  ## if type_suffix and use_suffix.value then
    local value_str <close> = tostring(value)
    return value_str .. #[type_suffix]#
  ## else
    return tostring(value)
  ## end
end

local function inspect_enum_value(value: a_enum_value): string
  local sb: stringbuilder <close>

  sb:write(#[tostring(value.type) .. '.']#)

  -- Note: this unrolls various `if`s, just to find and write to sb the right enum field
  -- correspondent to the value
  ## for _, field in ipairs(value.type.fields) do
    if value == #[field.value]# then
      sb:write(#[field.name]#)
    end
  ## end

  sb:writef(#[' --[[ %d'.. short_suffixes[value.type.subtype.name] ..' ]]']#, value)

  return tostring(sb)
end

local function non_aggregate_value(value: a_non_aggregate, use_suffix: boolean <comptime>): string
  ## if value.type.is_enum then
    return inspect_enum_value(value)

  ## elseif is_simple_primitive(value.type) then
    return inspect_simple_value(value, use_suffix)

  ## elseif value.type.is_pointer then
    return inspect_pointer_value(value)

  ## elseif value.type.is_nilptr then
    return 'nilptr'

  ## else
    return 'Unknown'
  ## end
end

## local function MACRO_inspect_array_value(value, inspect_array_value_fn_name)
  do
    local sb: stringbuilder <close>

    sb:write(#['(@' .. tostring(value.type) .. '){ ']#)

    for i = 0, < #(#[value]#) do
      local value_str <close> = (do
        ## if value.type.subtype.is_stringy then
          in inspect_stringy_value(#[value]#[i])

        ## elseif value.type.subtype.is_function then
          in inspect_function_value(#[value]#[i], 'array element')

        ## elseif value.type.subtype.is_union then
          in inspect_union_value(#[value]#[i])

        ## elseif not value.type.subtype.is_aggregate then
          in non_aggregate_value(#[value]#[i], false)

        ## else
          ## if value.type.subtype.is_record then
            in inspect_record_value(#[value]#[i], 0, false)

          ## elseif value.type.subtype.is_array then
            in #|inspect_array_value_fn_name|#(#[value]#[i])
          ## end
        ## end
      end)

      if i < #value - 1 then
        sb:write(value_str, ', ')
      else
        sb:write(value_str)
      end
    end

    sb:write(" }")

    MACRO_str_result = tostring(sb)
  end
## end

local function inspect_record_value(value: a_record_value, level: integer, use_type_prefix: boolean): string
  local function inspect_array_value(value: a_array): string
    local MACRO_str_result: string
    MACRO_inspect_array_value!(value, 'inspect_array_value')
    return MACRO_str_result
  end

  local sb: stringbuilder <close>

  if use_type_prefix then
    sb:write(#['(@' .. tostring(value.type) .. '){\n']#)
  else
    sb:write('{\n')
  end

  local indentation_plus <close> = string.rep('  ', level + 1)

  ## for _, field in ipairs(value.type.fields) do
    sb:write(indentation_plus, #[field.name .. ' = ']#)

    local value_str <close> = (do
      ## if field.type.is_stringy then
        in inspect_stringy_value(value.#|field.name|#)

      ## elseif field.type.is_function then
        in inspect_function_value(value.#|field.name|#, 'field')

      ## elseif field.type.is_union then
        in inspect_union_value(value.#|field.name|#)

      ## elseif not field.type.is_aggregate then
        in non_aggregate_value(value.#|field.name|#, true)

      ## else
        ## if field.type.is_record then
          in inspect_record_value(value.#|field.name|#, (level + 1), true)

        ## elseif field.type.is_array then
          in inspect_array_value(value.#|field.name|#)

        ## else
          in 'Unknown'
        ## end
      ## end
    end)

    sb:write(value_str, ',\n')
  ## end

  local indentation <close> = string.rep('  ', level)
  sb:write(indentation, '}')

  return tostring(sb)
end

local function inspect_array_value(value: a_array): string
  local MACRO_str_result: string
  MACRO_inspect_array_value!(value, 'inspect_array_value')
  return MACRO_str_result
end

-- the inspector module
global function inspector(value: auto): string
  ## if value.type.is_stringy then
    return inspect_stringy_value(value)

  ## elseif value.type.is_union then
    return inspect_union_value(value)

  ## elseif value.type.is_procedure then
    return tostring(#[inspect_procedure_value(value)]#)

  ## elseif not value.type.is_aggregate then
    return non_aggregate_value(value, true)

  ## else
    ## if value.type.is_record then
      return inspect_record_value(value, 0, true)

    ## elseif value.type.is_array then
      return inspect_array_value(value)
    ## end
  ## end

  return tostring('Unknown')
end
